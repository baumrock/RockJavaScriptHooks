;if(typeof ProcessWire=="undefined")ProcessWire={};(()=>{ProcessWire.addHookAfter=addHookAfter;ProcessWire.addHookBefore=addHookBefore;ProcessWire.wire=wire;const hooks={after:{},before:{},};class HookEvent{constructor(data){this.object=data.object;this._arguments=data.arguments;this.replace=!1;this.return=data.return}
get arguments(){const self=this;return new Proxy(function(){if(arguments.length===0)return self._arguments;if(arguments.length===1)return self._arguments[arguments[0]];if(arguments.length===2)
self._arguments[arguments[0]]=arguments[1]},{get(target,prop){if(prop==="length")return self._arguments.length;const index=parseInt(prop,10);return isNaN(index)?undefined:self._arguments[index]},set(target,prop,value){const index=parseInt(prop,10);if(!isNaN(index)){self._arguments[index]=value;return!0}
return!1},})}}
function addHookAfter(name,fn,priority=100){const _hooks=hooks.after[name]||[];_hooks.push({name,fn,priority});_hooks.sort((a,b)=>a.priority-b.priority);hooks.after[name]=_hooks}
function addHookBefore(name,fn,priority=100){const _hooks=hooks.before[name]||[];_hooks.push({name,fn,priority});_hooks.sort((a,b)=>a.priority-b.priority);hooks.before[name]=_hooks}
function executeHooks(type,hookName,hookEvent){const _hooks=hooks[type][hookName]||[];for(let i=0;i<_hooks.length;i++){try{_hooks[i].fn(hookEvent);if(hookEvent.replace&&type==="before")break}catch(error){console.error(`Error in ${type} hook for ${hookName}:`,error);console.log("Hook:",_hooks[i]);console.log("HookEvent:",hookEvent)}}}
function wire(object,name=null,noProxy=!1){if(object.constructor.name!=="Object"){throw new Error("ProcessWire.wire() does not support classes. Please use plain objects instead.")}
if(!name){throw new Error("Please provide a name: ProcessWire.wire(object, name)")}
if(object.constructor.name==="Object")noProxy=!0;if(noProxy)return wireNoProxy(object,name);else return wireProxy(object,name)}
function wireNoProxy(object,name){let props=Object.getOwnPropertyDescriptors(object);for(let key in props){if(!key.startsWith("___"))continue;const originalMethod=props[key].value;if(typeof originalMethod!=="function")continue;let newMethod=key.slice(3);const hookName=`${name}::${newMethod}`;props[newMethod]={value:function(...args){const hookEvent=new HookEvent({arguments:args,object:this,});executeHooks("before",hookName,hookEvent);if(hookEvent.replace)return hookEvent.return;hookEvent.return=originalMethod.apply(this,hookEvent.arguments());executeHooks("after",hookName,hookEvent);return hookEvent.return},}}
return Object.create(Object.getPrototypeOf(object),props)}
const HookHandler={get:function(data,prop){const object=data.object;if(typeof prop!=="string")return object[prop];let hookObjectName=data.name;if(!hookObjectName)hookObjectName=object.constructor.name;const selector=`${hookObjectName}::${prop}`;if(prop.startsWith("___"))return object[prop];if(typeof object[`___${prop}`]==="undefined")return object[prop];return function(...args){const hookEvent=new HookEvent({arguments:args,object:this,});executeHooks("before",selector,hookEvent);if(hookEvent.replace)return hookEvent.return;hookEvent.return=object[`___${prop}`].apply(this,hookEvent.arguments());executeHooks("after",selector,hookEvent);return hookEvent.return}},};function wireProxy(object,name){return new Proxy({object:object,name:name,},HookHandler)}})()